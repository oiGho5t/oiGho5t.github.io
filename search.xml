<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Ethernaut</title>
      <link href="/2026/02/15/ethernaut%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
      <url>/2026/02/15/ethernaut%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h3 id="Hello-Ethernaut"><a href="#Hello-Ethernaut" class="headerlink" title="Hello Ethernaut"></a>Hello Ethernaut</h3><p>设置扩展程序的MetaMask，连接自己的MetaMask<br>打开控制台输入player即可看到玩家的地址<br>**help()**可以查看控制台还有什么功能</p><table><thead><tr><th>(index)</th><th>Value</th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td>player</td><td>‘current player address’</td></tr><tr><td>ethernaut</td><td>‘main game contract’</td></tr><tr><td>level</td><td>‘current level contract address’</td></tr><tr><td>contract</td><td>‘current level contract instance (if created)’</td></tr><tr><td>instance</td><td>‘current level instance contract address (if created)’</td></tr><tr><td>version</td><td>‘current game version’</td></tr><tr><td>getBalance(address)</td><td>‘gets balance of address in ether’</td></tr><tr><td>getBlockNumber()</td><td>‘gets current network block number’</td></tr><tr><td>sendTransaction({options})</td><td>‘send transaction util’</td></tr><tr><td>getNetworkId()</td><td>‘get ethereum network id’</td></tr><tr><td>toWei(ether)</td><td>‘convert ether units to wei’</td></tr><tr><td>fromWei(wei)</td><td>‘convert wei units to ether’</td></tr><tr><td>deployAllContracts()</td><td>‘Deploy all the remaining contracts on the current network.’</td></tr><tr><td><a href="https://sepolia-faucet.pk910.de/">https://sepolia-faucet.pk910.de/</a></td><td></td></tr><tr><td>我是在上述水龙头网址输入自己的address,然后领取一些SepETH供开启新实例，不然没办法打开实例</td><td></td></tr><tr><td>![[截屏2026-02-15 16.12.02.png]]</td><td></td></tr></tbody></table><h3 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h3><p>合约如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Fallback &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public contributions;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        contributions[msg.sender] = 1000 * (1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        require(msg.sender == owner, &quot;caller is not the owner&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function contribute() public payable &#123;</span><br><span class="line">        require(msg.value &lt; 0.001 ether);</span><br><span class="line">        contributions[msg.sender] += msg.value;</span><br><span class="line">        if (contributions[msg.sender] &gt; contributions[owner]) &#123;</span><br><span class="line">            owner = msg.sender;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getContribution() public view returns (uint256) &#123;</span><br><span class="line">        return contributions[msg.sender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() public onlyOwner &#123;</span><br><span class="line">        payable(owner).transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过这关你需要</strong></p><ol><li>获得这个合约的所有权</li><li>把他的余额减到0</li></ol><p><strong>这可能有帮助</strong></p><ul><li>如何通过与ABI互动发送ether</li><li>如何在ABI之外发送ether</li><li>转换 wei&#x2F;ether 单位 (参见 <code>help()</code> 命令)</li><li>Fallback 方法</li></ul><p>OK，现在来分析这个合约</p><h5 id="关键函数"><a href="#关键函数" class="headerlink" title="关键函数"></a>关键函数</h5><ol><li><strong>constructor()</strong> - 部署时设置部署者为owner，并给予1000 ether的贡献值</li><li><strong>contribute()</strong> - 接受小于0.001 ether的捐款<ul><li>如果捐款者累计贡献超过owner，可以成为新owner</li></ul></li><li><strong>withdraw()</strong> - 只有owner可以提取合约内所有ETH</li><li><strong>receive()</strong> - 特殊的回退函数，当合约收到ETH时触发<ul><li>要求：<code>msg.value &gt; 0</code> 且 <code>contributions[msg.sender] &gt; 0</code></li><li>条件满足时，调用者直接成为owner</li></ul></li></ol><p>所以让我们先调用 <code>contribute()</code> 发送少量 ETH(小于 0.001 ETH).</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">await contract.contribute.sendTransaction(&#123; value: 1 &#125;)</span><br></pre></td></tr></table></figure><p>向合约捐赠 <strong>1 wei</strong>（小于 0.001 ETH），满足 <code>contribute()</code> 的入金限制。<br>然后在MetaMask上确认</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">await contract.sendTransaction(&#123; value: 1 &#125;)</span><br></pre></td></tr></table></figure><p>直接向合约地址转账 <strong>1 wei</strong>（任意正数均可）.<br>这会触发合约的 <code>receive()</code> 函数，检查到 <code>msg.value &gt; 0</code> 且 <code>contributions[msg.sender] &gt; 0</code>，于是将 <code>owner</code> 设置为你的地址.<br>等待交易确认后，可通过 <code>await contract.owner()</code> 验证，返回了我的地址，所以现在我就是owner<br>然后调用withdraw()把钱取走</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">await contract.withdraw()</span><br></pre></td></tr></table></figure><p>然后提交实例，他会提示我通过了！！<br>![[Pasted image 20260215163402.png]]<br><strong>fallback &#x2F; receive 触发机制</strong></p><table><thead><tr><th>场景</th><th>会触发哪个函数</th></tr></thead><tbody><tr><td>调用不存在函数，且没有 receive()</td><td>fallback()</td></tr><tr><td>向合约地址发送 ETH（无 calldata）</td><td>receive()</td></tr><tr><td>调用不存在函数，但有 calldata（不为空）</td><td>fallback()</td></tr><tr><td>调用存在的普通函数</td><td>正常函数</td></tr><tr><td>ai对两者解释如下：</td><td></td></tr></tbody></table><h4 id="fallback-函数"><a href="#fallback-函数" class="headerlink" title="fallback 函数"></a><strong>fallback 函数</strong></h4><p>是一个特殊的、未命名的外部函数，每个合约最多可以包含一个。它主要在两种情况下被触发：</p><ol><li><strong>合约收到纯 ETH 转账（没有 <code>msg.data</code>）</strong></li><li><strong>调用的函数不存在于合约中</strong><br>从 Solidity 0.6.x 开始，fallback 功能被拆分为两个独立的特殊函数：</li></ol><ul><li><strong><code>receive() external payable</code></strong>：专门处理纯 ETH 转账。</li><li><strong><code>fallback() external payable</code></strong>：处理所有其他情况（函数不存在或 <code>msg.data</code> 非空）。</li></ul><h4 id="receive-函数"><a href="#receive-函数" class="headerlink" title="receive() 函数"></a><strong><code>receive()</code> 函数</strong></h4><ul><li><strong>必须标记为 <code>external</code> 和 <code>payable</code></strong>。</li><li>不能有参数，不能返回值。</li><li>一个合约最多只能定义一个 <code>receive</code> 函数。<br><strong>触发条件</strong><br>当向合约发送 ETH 且<strong>交易数据为空</strong>（<code>msg.data.length == 0</code>）时，<code>receive</code> 会被调用。例如：</li><li>通过 <code>send</code> 或 <code>transfer</code> 发送 ETH（gas 固定 2300）。</li><li>直接通过钱包向合约地址转账。</li><li>调用 <code>address.call{value: x}(&quot;&quot;)</code>（空 calldata）。</li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> web3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solidity学习日记</title>
      <link href="/2026/02/13/Solidity%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
      <url>/2026/02/13/Solidity%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>下面是我在cryptozombies学习的过程:<br><a href="https://cryptozombies.io/">https://cryptozombies.io/</a></p><h5 id="zombiefactory-sol"><a href="#zombiefactory-sol" class="headerlink" title=".&#x2F;zombiefactory.sol"></a>.&#x2F;zombiefactory.sol</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.5.0 &lt;0.6.0;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory &#123;</span><br><span class="line">event NewZombie(uint zombieId, string name, uint dna);</span><br><span class="line"></span><br><span class="line">uint dnaDigits = 16;</span><br><span class="line">uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">struct Zombie &#123;</span><br><span class="line">string name;</span><br><span class="line">uint dna;</span><br><span class="line">&#125;</span><br><span class="line">Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">mapping (uint =&gt; address) public zombieToOwner;</span><br><span class="line">mapping (address =&gt; uint) ownerZombieCount;</span><br><span class="line"></span><br><span class="line">function _createZombie(string memory _name, uint _dna) private &#123;</span><br><span class="line">uint id = zombies.push(Zombie(_name, _dna)) - 1;</span><br><span class="line">zombieToOwner[id] = msg.sender;</span><br><span class="line">ownerZombieCount[msg.sender]++;</span><br><span class="line">emit NewZombie(id, _name, _dna);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _generateRandomDna(string memory _str) private view returns (uint) &#123;</span><br><span class="line">uint rand = uint(keccak256(abi.encodePacked(_str)));</span><br><span class="line">return rand % dnaModulus;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createRandomZombie(string memory _name) public &#123;</span><br><span class="line">require(ownerZombieCount[msg.sender] == 0);</span><br><span class="line">uint randDna = _generateRandomDna(_name);</span><br><span class="line">_createZombie(_name, randDna);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ZombieFeeding is ZombieFactory&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="zombiefeeding-sol"><a href="#zombiefeeding-sol" class="headerlink" title="zombiefeeding.sol"></a>zombiefeeding.sol</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.5.0 &lt;0.6.0;</span><br><span class="line"></span><br><span class="line">import &quot;./zombiefactory.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract KittyInterface &#123;</span><br><span class="line">function getKitty(uint256 _id) external view returns (</span><br><span class="line">bool isGestating,</span><br><span class="line">bool isReady,</span><br><span class="line">uint256 cooldownIndex,</span><br><span class="line">uint256 nextActionAt,</span><br><span class="line">uint256 siringWithId,</span><br><span class="line">uint256 birthTime,</span><br><span class="line">uint256 matronId,</span><br><span class="line">uint256 sireId,</span><br><span class="line">uint256 generation,</span><br><span class="line">uint256 genes</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">contract ZombieFeeding is ZombieFactory &#123;</span><br><span class="line">address ckAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;</span><br><span class="line">KittyInterface kittyContract = KittyInterface(ckAddress);</span><br><span class="line"></span><br><span class="line">function feedAndMultiply(uint _zombieId, uint _targetDna) public &#123;</span><br><span class="line">require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">_targetDna = _targetDna % dnaModulus;</span><br><span class="line">uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">_createZombie(&quot;NoName&quot;, newDna);</span><br><span class="line">&#125;</span><br><span class="line">function feedOnKitty(uint _zombieId, uint _kittyId) public &#123;</span><br><span class="line">uint kittyDna;</span><br><span class="line">(,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);</span><br><span class="line">feedAndMultiply(_zombieId, kittyDna);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Solidity</code> 是一种用于编写以太坊虚拟机（<code>EVM</code>）智能合约的编程语言。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.21;</span><br><span class="line">contract HelloWeb3&#123;</span><br><span class="line">    string public _string = &quot;Hello Web3!&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 3-4 行是合约部分。第 3 行创建合约（contract），并声明合约名为 <code>HelloWeb3</code>。第 4 行是合约内容，声明了一个 string（字符串）变量 <code>_string</code>，并赋值为 “Hello Web3!”。</p><h4 id="值类型："><a href="#值类型：" class="headerlink" title="值类型："></a>值类型：</h4><ol><li> <strong>值类型(Value Type)</strong> ：包括布尔型，整数型等等，这类变量赋值时候直接传递数值。</li><li> <strong>引用类型(Reference Type)</strong> ：包括数组和结构体，这类变量占空间大，赋值时候直接传递地址（类似指针）。</li><li> <strong>映射类型(Mapping Type)</strong> : Solidity中存储键值对的数据结构，可以理解为哈希表</li></ol><h4 id="1-布尔型："><a href="#1-布尔型：" class="headerlink" title="1. 布尔型："></a>1. 布尔型：</h4><p>布尔值的运算符包括：</p><ul><li><code>!</code> （逻辑非）</li><li><code>&amp;&amp;</code> （逻辑与，”and”）</li><li><code>||</code> （逻辑或，”or”）</li><li><code>==</code> （等于）</li><li><code>!=</code> （不等于）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 布尔运算</span><br><span class="line">bool public _bool1 = !_bool; // 取非</span><br><span class="line">bool public _bool2 = _bool &amp;&amp; _bool1; // 与</span><br><span class="line">bool public _bool3 = _bool || _bool1; // 或</span><br><span class="line">bool public _bool4 = _bool == _bool1; // 相等</span><br><span class="line">bool public _bool5 = _bool != _bool1; // 不相等</span><br></pre></td></tr></table></figure><p>复制代码</p><p>在上述代码中：变量 <code>_bool</code> 的取值是 <code>true</code>；<code>_bool1</code> 是 <code>_bool</code> 的非，为 <code>false</code>；<code>_bool &amp;&amp; _bool1</code> 为 <code>false</code>；<code>_bool || _bool1</code> 为 <code>true</code>；<code>_bool == _bool1</code> 为 <code>false</code>；<code>_bool != _bool1</code> 为 <code>true</code>。</p><p><strong>值得注意的是：</strong> <code>&amp;&amp;</code> 和 <code>||</code> 运算符遵循短路规则，这意味着，假如存在 <code>f(x) || g(y)</code> 的表达式，如果 <code>f(x)</code> 是 <code>true</code>，<code>g(y)</code> 不会被计算，即使它和 <code>f(x)</code> 的结果是相反的。假如存在<code>f(x) &amp;&amp; g(y)</code> 的表达式，如果 <code>f(x)</code> 是 <code>false</code>，<code>g(y)</code> 不会被计算。 所谓“短路规则”，一般出现在逻辑与（&amp;&amp;）和逻辑或（||）中。 当逻辑与（&amp;&amp;）的第一个条件为false时，就不会再去判断第二个条件； 当逻辑或（||）的第一个条件为true时，就不会再去判断第二个条件，这就是短路规则。</p><h4 id="2-地址类型"><a href="#2-地址类型" class="headerlink" title="2. 地址类型"></a>2. 地址类型</h4><p>地址类型(address)有两类：</p><ul><li>普通地址（address）: 存储一个 20 字节的值（以太坊地址的大小）。</li><li>payable address: 比普通地址多了 <code>transfer</code> 和 <code>send</code> 两个成员方法，用于接收转账。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 地址</span><br><span class="line">address public _address = 0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71;</span><br><span class="line">address payable public _address1 = payable(_address); // payable address，可以转账、查余额</span><br><span class="line">// 地址类型的成员</span><br><span class="line">uint256 public balance = _address1.balance; // balance of address</span><br></pre></td></tr></table></figure><h4 id="3枚举-enum"><a href="#3枚举-enum" class="headerlink" title="3枚举 enum"></a>3枚举 enum</h4><p>枚举（<code>enum</code>）是 Solidity 中用户定义的数据类型。它主要用于为 <code>uint</code> 分配名称，使程序易于阅读和维护。它与 <code>C 语言</code> 中的 <code>enum</code> 类似，使用名称来代替从 <code>0</code> 开始的 <code>uint</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 用enum将uint 0， 1， 2表示为Buy, Hold, Sell</span><br><span class="line">enum ActionSet &#123; Buy, Hold, Sell &#125;</span><br><span class="line">// 创建enum变量 action</span><br><span class="line">ActionSet action = ActionSet.Buy;</span><br></pre></td></tr></table></figure><p>枚举可以显式地和 <code>uint</code> 相互转换，并会检查转换的无符号整数是否在枚举的长度内，否则会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// enum可以和uint显式的转换</span><br><span class="line">function enumToUint() external view returns(uint)&#123;</span><br><span class="line">    return uint(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>enum</code> 是一个比较冷门的数据类型，几乎没什么人用。</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function &lt;function name&gt;([parameter types[, ...]]) &#123;internal|external|public|private&#125; [pure|view|payable] [virtual|override] [&lt;modifiers&gt;]</span><br><span class="line">[returns (&lt;return types&gt;)]&#123; &lt;function body&gt; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看着有一些复杂，让我们从前往后逐个解释(方括号中的是可写可不 写的关键字)：</p><ol><li> <code>function</code>：声明函数时的固定用法。要编写函数，就需要以 <code>function</code> 关键字开头。</li><li> <code>&lt;function name&gt;</code>：函数名。</li><li> <code>([parameter types[, ...]])</code>：圆括号内写入函数的参数，即输入到函数的变量类型和名称。</li><li> <code>{internal|external|public|private}</code>：函数可见性说明符，共有4种。<ul><li><code>public</code>：内部和外部均可见。</li><li><code>private</code>：只能从本合约内部访问，继承的合约也不能使用。</li><li><code>external</code>：只能从合约外部访问（但内部可以通过 <code>this.f()</code> 来调用，<code>f</code>是函数名）。</li><li><code>internal</code>: 只能从合约内部访问，继承的合约可以用。<br> <strong>注意 1</strong>：合约中定义的函数需要明确指定可见性，它们没有默认值。<br> <strong>注意 2</strong>：<code>public|private|internal</code> 也可用于修饰状态变量(定义可参考<a href="https://www.wtf.academy/zh/course/solidity101/%5B../05_DataStorage/readme.md#1-%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%5D(https://github.com/AmazingAng/WTF-Solidity/tree/main/05_DataStorage#1-%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F)">WTF Solidity 第5讲的相关内容</a>)。<code>public</code>变量会自动生成同名的<code>getter</code>函数，用于查询数值。未标明可见性类型的状态变量，默认为<code>internal</code>。</li></ul></li><li> <code>[pure|view|payable]</code>：决定函数权限&#x2F;功能的关键字。<code>payable</code>（可支付的）很好理解，带着它的函数，运行的时候可以给合约转入 ETH。<code>pure</code> 和 <code>view</code> 的介绍见下一节。</li><li> <code>[virtual|override]</code>: 方法是否可以被重写，或者是否是重写方法。<code>virtual</code>用在父合约上，标识的方法可以被子合约重写。<code>override</code>用在自合约上，表名方法重写了父合约的方法。</li><li> <code>&lt;modifiers&gt;</code>: 自定义的修饰器，可以有0个或多个修饰器。</li><li> <code>[returns ()]</code>：函数返回的变量类型和名称。</li><li> <code>&lt;function body&gt;</code>: 函数体。</li></ol><h4 id="到底什么是-Pure-和View？"><a href="#到底什么是-Pure-和View？" class="headerlink" title="到底什么是 Pure 和View？"></a>到底什么是 <code>Pure</code> 和<code>View</code>？</h4><p>刚开始学习 <code>solidity</code> 时，<code>pure</code> 和 <code>view</code> 关键字可能令人费解，因为其他编程语言中没有类似的关键字。<code>solidity</code> 引入这两个关键字主要是因为 以太坊交易需要支付气费（gas fee）。合约的状态变量存储在链上，gas fee 很贵，如果计算不改变链上状态，就可以不用付 <code>gas</code>。包含 <code>pure</code> 和 <code>view</code> 关键字的函数是不改写链上状态的，因此用户直接调用它们是不需要付 gas 的（注意，合约中非 <code>pure</code>&#x2F;<code>view</code> 函数调用 <code>pure</code>&#x2F;<code>view</code> 函数时需要付gas）。</p><p>在以太坊中，以下语句被视为修改链上状态：</p><ol><li>写入状态变量。</li><li>释放事件。</li><li>创建其他合约。</li><li>使用 <code>selfdestruct</code>.</li><li>通过调用发送以太币。</li><li>调用任何未标记 <code>view</code> 或 <code>pure</code> 的函数。</li><li>使用低级调用（low-level calls）。</li><li>使用包含某些操作码的内联汇编。</li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="1-pure-和-view"><a href="#1-pure-和-view" class="headerlink" title="1. pure 和 view"></a>1. pure 和 view</h5><p>我们在合约里定义一个状态变量 <code>number</code>，初始化为 5。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.21;</span><br><span class="line">contract FunctionTypes&#123;</span><br><span class="line">    uint256 public number = 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个 <code>add()</code> 函数，每次调用会让 <code>number</code> 增加 1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 默认function</span><br><span class="line">function add() external&#123;</span><br><span class="line">    number = number + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>add()</code> 函数被标记为 <code>pure</code>，比如 <code>function add() external pure</code>，就会报错。因为 <code>pure</code> 是不配读取合约里的状态变量的，更不配改写。那 <code>pure</code> 函数能做些什么？举个例子，你可以给函数传递一个参数 <code>_number</code>，然后让他返回 <code>_number + 1</code>，这个操作不会读取或写入状态变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// pure: 纯纯牛马</span><br><span class="line">function addPure(uint256 _number) external pure returns(uint256 new_number)&#123;</span><br><span class="line">    new_number = _number + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-internal-v-s-external"><a href="#2-internal-v-s-external" class="headerlink" title="2. internal v.s. external"></a>2. internal v.s. external</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// internal: 内部函数</span><br><span class="line">function minus() internal &#123;</span><br><span class="line">    number = number - 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 合约内的函数可以调用内部函数</span><br><span class="line">function minusCall() external &#123;</span><br><span class="line">    minus();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义一个 <code>internal</code> 的 <code>minus()</code> 函数，每次调用使得 <code>number</code> 变量减少 1。由于 <code>internal</code> 函数只能由合约内部调用，我们必须再定义一个 <code>external</code> 的 <code>minusCall()</code> 函数，通过它间接调用内部的 <code>minus()</code> 函数。</p><h5 id="3-payable"><a href="#3-payable" class="headerlink" title="3. payable"></a>3. payable</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// payable: 递钱，能给合约支付eth的函数</span><br><span class="line">function minusPayable() external payable returns(uint256 balance) &#123;</span><br><span class="line">    minus();    </span><br><span class="line">    balance = address(this).balance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义一个 <code>external payable</code> 的 <code>minusPayable()</code> 函数，间接的调用 <code>minus()</code>，并且返回合约里的 ETH 余额（<code>this</code> 关键字可以让我们引用合约地址）。我们可以在调用 <code>minusPayable()</code> 时往合约里转入1个 ETH。</p><h4 id="返回值：return-和-returns"><a href="#返回值：return-和-returns" class="headerlink" title="返回值：return 和 returns"></a>返回值：return 和 returns</h4><p>Solidity 中与函数输出相关的有两个关键字：<code>return</code>和<code>returns</code>。它们的区别在于：</p><ul><li><code>returns</code>：跟在函数名后面，用于声明返回的变量类型及变量名。</li><li><code>return</code>：用于函数主体中，返回指定的变量。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 返回多个变量</span><br><span class="line">function returnMultiple() public pure returns(uint256, bool, uint256[3] memory)&#123;</span><br><span class="line">    return(1, true, [uint256(1),2,5]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们利用 <code>returns</code> 关键字声明了有多个返回值的 <code>returnMultiple()</code> 函数，然后我们在函数主体中使用 <code>return(1, true, [uint256(1),2,5])</code> 确定了返回值。</p><p>这里<code>uint256[3]</code>声明了一个长度为<code>3</code>且类型为<code>uint256</code>的数组作为返回值。因为<code>[1,2,3]</code>会默认为<code>uint8(3)</code>，因此<code>[uint256(1),2,5]</code>中首个元素必须强转<code>uint256</code>来声明该数组内的元素皆为此类型。数组类型返回值默认必须用memory修饰</p><h4 id="以太单位"><a href="#以太单位" class="headerlink" title="以太单位"></a>以太单位</h4><p><code>Solidity</code>中不存在小数点，以<code>0</code>代替为小数点，来确保交易的精确度，并且防止精度的损失，利用以太单位可以避免误算的问题，方便程序员在合约中处理货币交易。</p><ul><li><code>wei</code>: 1</li><li><code>gwei</code>: 1e9 &#x3D; 1000000000</li><li><code>ether</code>: 1e18 &#x3D; 1000000000000000000</li></ul><h4 id="时间单位"><a href="#时间单位" class="headerlink" title="时间单位"></a>时间单位</h4><p>可以在合约中规定一个操作必须在一周内完成，或者某个事件在一个月后发生。这样就能让合约的执行可以更加精确，不会因为技术上的误差而影响合约的结果。因此，时间单位在<code>Solidity</code>中是一个重要的概念，有助于提高合约的可读性和可维护性。</p><ul><li><code>seconds</code>: 1</li><li><code>minutes</code>: 60 seconds &#x3D; 60</li><li><code>hours</code>: 60 minutes &#x3D; 3600</li><li><code>days</code>: 24 hours &#x3D; 86400</li><li><code>weeks</code>: 7 days &#x3D; 604800</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> web3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2026/02/05/hello-world/"/>
      <url>/2026/02/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
